function  [classInfo,...
	   nseData,nseResults,...
	   numClasses,numDims,numObs,numTimeSteps,...
	   SINDyData,SINDyResults,...
	   atkData,genDistr] = ...
	   attackingLearnPlusPlus_chrisAttack_SINDy(dataset,... % General setting
                                                kernel,... % Learn++.NSE & AttackSVM setting
                                                lambda,polyOrder,... % SINDy Setting
                                                useSine,sineMultiplier,... % SINDy Setting
                                                useExp,expMultiplier,... % SINDy Setting
                                                maxSteps,stepSize,... % AttackSVM setting
                                                degree,coef0,... % AttackSVM setting
                                                numAtkPts,...
                                                c) % AttackSVM setting
     [classInfo,...
     nseData,nseResults,...
     numClasses,numDims,...
     numObs,numTimeSteps] = learnPlusPlus_NSE_Preprocessing(dataset,kernel);

    [SINDyData,SINDyArray,SINDyResults] = SINDyPreprocessing(classInfo,...
	                                                     numClasses,numTimeSteps,...
	                                                     lambda,polyOrder,...
	                                                     useSine,sineMultiplier,...
                                                             useExp,expMultiplier);

    [atkSet,atkData,...
     thereIsTimeToAttack,...
     genDistr] = chrisAttacks_With_SINDy_Preprocessing(kernel,...
	                                               maxSteps,stepSize,...
	                                               degree,coef0,...
	                                               numAtkPts,...
                                                       numObs,numDims,numTimeSteps,c);

    for iTStep = 1:numTimeSteps
        disp(iTStep)
        if (iTStep >= atkSet.timeToAttack-1 && thereIsTimeToAttack) % dont start attacking until timestep before time to attack
            for iClass = 1:numClasses
                [model, SINDyResults(iTStep,iClass).learnedFunctions] = ...
                SINDyArray(iClass).buildModel(SINDyData(iTStep,iClass).mu,...
                                                     1,...
                                                     SINDyData(iTStep).latestReset,...
                                                     iTStep,...
                                                     1);
                SINDyResults(iTStep,iClass).prediction = model(end,:);
                % Generate distribution for next time step
                % last row of SINDy.model is the predicted time step
                genDistr(iTStep+1).data(classInfo(iTStep,iClass).idx,:) = ...
                                   mvnrnd(SINDyResults(iTStep,iClass).prediction,...
                                          SINDyData(iTStep,iClass).sigma,...
                                          classInfo(iTStep,iClass).numObs);
                genDistr(iTStep+1).labels(classInfo(iTStep,iClass).idx,:) = ...
                              repmat(iClass,classInfo(iTStep,iClass).numObs,1);
            end
        end
        if (iTStep < atkSet.timeToAttack && thereIsTimeToAttack) % perform Learn++.NSE 
            if iTStep == 1
                [nseResults(iTStep).net,...
                nseResults(iTStep).f_measure,...
                nseResults(iTStep).g_mean,...
                nseResults(iTStep).precision,...
                nseResults(iTStep).recall,...
                nseResults(iTStep).errs_nse,...
                nseResults(iTStep).latestClassifier] = learn_nse_for_attacking(nseResults(iTStep).net,...
                                                    nseData(iTStep).dataTrain,...
                                                    nseData(iTStep).labelsTrain,...
                                                    nseData(iTStep).dataTest,...
                                                    nseData(iTStep).labelsTest);
            else
                [nseResults(iTStep).net,...
                nseResults(iTStep).f_measure,...
                nseResults(iTStep).g_mean,...
                nseResults(iTStep).precision,...
                nseResults(iTStep).recall,...
                nseResults(iTStep).errs_nse,...
                nseResults(iTStep).latestClassifier] = learn_nse_for_attacking(nseResults(iTStep-1).net,...
                                                    nseData(iTStep).dataTrain,...
                                                    nseData(iTStep).labelsTrain,...
                                                    nseData(iTStep).dataTest,...
                                                    nseData(iTStep).labelsTest);
            end
        elseif (iTStep >= atkSet.timeToAttack && thereIsTimeToAttack) % perform Learn++.NSE with attack points added

            % need to construct boundary for n dimensional dataset
            atkSet.boundary = [min(genDistr(iTStep).data);max(genDistr(iTStep).data)];
            [atkData(iTStep).points,atkData(iTStep).labels] = ...
                                        chrisAttacks(genDistr(iTStep).data,...
                                                     genDistr(iTStep).labels,...
                                                     atkSet);
            [nseResults(iTStep).net,...
            nseResults(iTStep).f_measure,...
            nseResults(iTStep).g_mean,...
            nseResults(iTStep).precision,...
            nseResults(iTStep).recall,...
            nseResults(iTStep).errs_nse,...
            nseResults(iTStep).latestClassifier] = ...
            learn_nse_for_attacking(nseResults(iTStep-1).net,...
                                    [nseData(iTStep).dataTrain;atkData(iTStep).points],...
                                    [nseData(iTStep).labelsTrain;atkData(iTStep).labels'],...
                                    nseData(iTStep).dataTest,...
                                    nseData(iTStep).labelsTest);
            % Check generated distribution vs actual results to determine if we
            % need to reset SINDy
%             for iClass = 1:numClasses
%                 [drift] = checkSINDy(SINDyArray,SINDyData,StdevThresh,iTStep,iClass);
%                 if drift == true
%                     for iTStep2 = iTStep:numTimeSteps
%                         SINDyData(iTStep2,iClass).mu = ...
%                             SINDyData(iTStep2,iClass).mu(iTStep-SINDyData(iTStep,iClass).latestReset:end,:);
%                     end
%                     [SINDyData(iTStep:end,iClass).latestReset] = deal(iTStep-1);
%                     if iClass == atkSet.c
%                         if atkSet.timeToAttack + iTStep > numTimeSteps
%                             thereIsTimeToAttack = false;
%                         else
%                             atkSet.timeToAttack = atkSet.timeToAttack + iTStep;
%                         end
%                     end
%                 end
%             end
        else
            [nseResults(iTStep).net,...
            nseResults(iTStep).f_measure,...
            nseResults(iTStep).g_mean,...
            nseResults(iTStep).precision,...
            nseResults(iTStep).recall,...
            nseResults(iTStep).errs_nse,...
            nseResults(iTStep).latestClassifier] = learn_nse_for_attacking(nseResults(iTStep-1).net,...
                                                nseData(iTStep).dataTrain,...
                                                nseData(iTStep).labelsTrain,...
                                                nseData(iTStep).dataTest,...
                                                nseData(iTStep).labelsTest);    
        end
    end
end